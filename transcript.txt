 Now let's see the drawbacks of Processor-Voriented Programming. Mainly, there are two types of languages, sorry, available. Processor-oriented programming languages and object-oriented programming languages. The best examples for Processor-Voriented Programming languages are C, Fortran and Cobal. There are several problems with Processor-Voriented Programming languages. We can overcome all those problems with the help of object-oriented programming languages. The best examples for object-oriented programming languages are C++, Java, Fython, C-Sharp, Alipay's we have several object-oriented programming languages. In this video, we will discuss about the drawbacks or the disadvantages of Processor-Voriented Programming languages. In short, we can call Processor-Voriented Programming as POP. And object-oriented programming as VOOP. Let's see these six problems. Let's see the first problem. Processor-Voriented Codes are very difficult to maintain. If the code proves not yet, so forgive every Processor-Voriented Programming language. There is some maximum limit for the length of the code. Let's take C language. Why? Because the best example for Processor-Voriented Programming languages is C language. Let us assume that the maximum limit of a C program is 10,000 lines of code. So if you want to write beyond 10,000 lines of code, then it would become extremely difficult to maintain the corresponding program. So that is the first problem here. What is the problem? If the code grows larger than beyond the limit of the program, then it would become very difficult to maintain the program. That is the first problem. And let's see the second problem. Data is exposed to whole program, so no security for data. Let's take a C program which contains structure. By default, all the members of the structure are public. Why? Because we know that there are no access specifiers in the C program in language. So by default, all the members of the structure are public. So there is no security for our data. In the entire program, our data will be exposed. So our data can be used by the entire program. So there is no security for our data. We can overcome that problem with the help of food. Let's say the third problem. Difficult to relate with the real-world objects. In Prociseur oriented programming, such as C, we can create some structure variables. A batch. It is very very difficult to relate with real-world objects. Various we can relate with real-world objects. Indian easiest manner in object oriented programming languages. In Woop, we have a class. With the help of class, we can create some objects. Objects are nothing but real-world entities. So in Woop, we can relate with real-world objects in extremely easier manner. Various instructions in C language in Prociseur oriented programming. It would become very difficult to relate with the real-world objects. Now let's see the next problem. Difficult to create new data types. With the help of structures, we can create new data types. But it would become more complex. Various in Woop, the best example for Woopies Java. In Java, with the help of a class, we can create usually fine data types. With the help of those user-defined data types, we can create objects in very easiest manner. Then in Prociseur oriented programming. So we can say that in the PWP, it is difficult to create new data types. Various in Woop, it is very very extremely easy in order to create the new data types. Let's see the next problem. Importance is given to operations on data rather than data. The name itself specifies the meaning. Prociseur oriented programming means the more importance will be given to the Prociseur. Prociseur means functions. So rather than data, rather than the corresponding values, the more importance will be given to the operations on the data. The more importance will be given to the corresponding Prociseur's or functions. That is the problem here. Actually, we have to give more importance for the data. Rather than operations on the data, that is nothing but Prociseur's. So that is one more problem with PWP. Let's see the last problem. Prociseur languages doesn't have automatic memory management. It has like, we have in Java. The major advantage of Java is, Java is excellent in memory management. In Java, there is no need to release the memory explicitly for allocating the memory we use just new operator. But there is no need to be allocate or release the memory for the object. If an object is no longer used, if an object is not referred to, then the corresponding object memory will be implicitly released by God-based collectile. Various that is not happened in Prociseur oriented programming languages such as C. In C, in order to release the memory explicitly, we use a free operator. But it is dynamic memory management concept. Various in Java, it is not necessary to release or to destroy the memory for the object. If the corresponding object is no longer referred to, then the object memory will be destroyed automatically. So, we can say that Prociseur oriented programming languages are weak in automatic memory management, various object-oriented programming languages such as Java is excellent in memory management. So, these are the several problems or several drawbacks of Prociseur oriented programming. We can solve all these problems with the help of object-oriented programming languages such as Java. So, this is about the drawbacks or the disadvantages of Prociseur oriented programming.